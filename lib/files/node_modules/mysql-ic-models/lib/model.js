var Base = require("./functions");
//var functions = new Base();
var _funs = Symbol();
var functions = Symbol();
module.exports = class Model{
    
    
    constructor(props,table,primary){
        this[_funs] = new Base();
        this[functions] = new Base()
        if(props) Object.assign(this,props);
        if(table && primary){
            this[functions].config(table,primary)
        }
        else this[functions].config(this.table,this.primaryKey)
        
    }

    static set funs(f){
        functions
    }
    static get funs(){
        return new Base()
    }

    static config(table,primary){
        this[functions].config(table,primary)
    }

    static set functionsx(functions){
        this[functions] = functions
    }

    static get _t(){
        return this.table
    }

    static get _pk(){
        return this.primaryKey
    }

    static get table(){
        
    }

    static get primaryKey(){
        
    }

    static build(){
        //this.functions
        this[functions] = new Base()
        this[functions].config(this.table,this.primaryKey);
        //var functionsx = new Base();
        //functionsx.config(this.table,this.primaryKey);
        //this.config(this.table,this.primaryKey)
        //console.log(functionsx)
        return this
    }
    static async rawQuery(query){
        return await this[functions].rawQuery(query)
    }

    watcher(prop,oldVal,newVal){
        
        if(newVal != oldVal){
            this.changed.push(newVal)
        }else{
            this.changed.pop(newVal);
        }
    }
    
    setTable(table){
        this.table = table;
    }

    async save(){
        var props = Object.assign({}, this);
        //Object.assign(this,props);
        return await this[functions].save(props)
        .then(res=>{
            if(res.insertId && res.insertId > 0){
                
                Object.defineProperty(this,res.primaryKeyName,{
                    value:res.insertId,
                    writable: true,
                    enumerable: true,
                    configurable: true});
                var props = Object.assign({}, this);
            }
            return res;
        })
        .catch(error=>{

        });

    }

    async delete(){
        var props = Object.assign({}, this);
        return await this[functions].delete(props)
        .then(res=>{
            return res;
        },rej=>{
            throw rej
        })
        .catch(error=>{
            throw error
        });
    }

    static async destroy(){
        return this[functions].destroy()
        .then(res=>{
            return res;
        })
        .catch(error=>{

        });
    }

    static join(relation,primary,foreign){
        this[functions].join(relation,primary,foreign);
        return this
    }

    static async find(id){
        
        let props = await this[functions].find(id)
        .then(res=>{
            return res;
        }).catch(error=>{
            throw error
        });
        if(props){
            Object.assign(this,props);
            return new Model(props,this.table,this.primaryKey);
        }
        return props;
        
    }

    static select(fields){
        this[functions].select(fields);
        return this
    }
    
    static andWhere(key,op,val){
        this[functions].andWhere(key,op,val);
        return this
    }
    
    static where(key,op,val){
       this[functions].where(key,op,val);
        return this
    }
    
    static orWhere(key,op,val){
        this[functions].orWhere(key,op,val);
        return this
    }

    static async update(fields){
        let res = await this[functions].update(fields)
        .then(res=>{
            return res;
        })
        .catch(error=>{

        });
        return res;
    }
    
    //Regresa un array de registros
    static async take(number){
        let props = await this[functions].take(number)
        .then(res=>{
            return res;
        }).catch( error =>{
            
        });
       
        return props
    }
    
    
    static orderBy(field,sort){
        this[functions].orderBy(field,sort);
        return this
    }

    static async first(){
        var props = await this[functions].first()
        .then(res=>{
            //console.log("RES: ",res);
            return res;
        }).catch(error =>{
            
        });
        if(this[functions].joins.length <= 0 && props){
            Object.assign(this,props);
            return new Model(props,this.table,this.primaryKey);
        }
       // console.log("OYE AQUI NO")
        return props;
    }

    static async all(){
        let props = await this[functions].all()
        .then(res=>{
            return res;
        }).catch( error =>{
            
        });
        return props;
    }
    
    static hasMany(relation,primary,foreign){
    
    }
    
    static hasOne(relation,primary,foreign){
    
    }

}