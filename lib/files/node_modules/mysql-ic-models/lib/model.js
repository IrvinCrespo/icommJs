var Base = require("./functions");
var functions;

module.exports = class Model{
    
    
    constructor(props,table,primary){
        functions = new Base()
        if(props) Object.assign(this,props);
        if(table && primary){
            functions.config(table,primary)
        }
        else functions.config(this.table,this.primaryKey)
        
    }
    
    static get functions(){
        return new Base();
    }
    static get _t(){
        return this.table
    }

    static get _pk(){
        return this.primaryKey
    }

    static get table(){
        
    }

    static get primaryKey(){
        
    }

    static build(){
        //this.functions
        functions = new Base();
       
        functions.config(this.table,this.primaryKey);
        return this
    }

    watcher(prop,oldVal,newVal){
     
        if(newVal != oldVal){
            this.changed.push(newVal)
        }else{
            this.changed.pop(newVal);
        }
    }
    
    setTable(table){
        this.table = table;
    }

    async save(){
        var props = Object.assign({}, this);
        //Object.assign(this,props);
        return await functions.save(props)
        .then(res=>{
            if(res.insertId && res.insertId > 0){
             
                Object.defineProperty(this,res.primaryKeyName,{
                    value:res.insertId,
                    writable: true,
                    enumerable: true,
                    configurable: true});
                var props = Object.assign({}, this);
                
                
            }
            return res;
        })
        .catch(error=>{

        });

    }

    async delete(){
        var props = Object.assign({}, this);
        return await functions.delete(props)
        .then(res=>{
            return res;
        })
        .catch(error=>{
            
        });
    }

    static async destroy(){
        return functions.destroy()
        .then(res=>{
            return res;
        })
        .catch(error=>{

        });
    }

    static async join(relation,primary,foreign){
        functions.andWhere(relation,primary,foreign);
        return this
    }

    static async find(id){
        
        let props = await functions.find(id)
        .then(res=>{
            return res;
        }).catch(error=>{
            throw error
        });
        if(props){
            Object.assign(this,props);
            return new Model(props,this.table,this.primaryKey);
        }
        return props;
        
    }

    static select(fields){
        this.query = functions.select(fields);
        return this
    }

    static join(relation,primary,foreign){
        functions.join(relation,primary,foreign);
        return this
    }
    
    static andWhere(key,op,val){
        functions.andWhere(key,op,val);
        return this
    }
    
    static where(key,op,val){
        this.query = functions.where(key,op,val);
        return this
    }
    
    static orWhere(key,op,val){
        return this
    }

    static async update(fields){
        let res = await functions.update(fields)
        .then(res=>{
            return res;
        })
        .catch(error=>{

        });
        return res;
    }
    
    //Regresa un array de registros
    static async take(number){
        let props = await functions.take(number)
        .then(res=>{
            return res;
        }).catch( error =>{
            
        });
       
        return props
    }
    
    
    static orderBy(field,sort){
        functions.orderBy(field,sort);
        return this
    }

    static async first(){
        let props = await functions.first()
        .then(res=>{
            //console.log("RES: ",res);
            return res;
        }).catch( error =>{
            
        });

        return props;
    }

    static async all(){
        let props = await functions.all()
        .then(res=>{
            return res;
        }).catch( error =>{
            
        });
        return props;
    }
    
    static hasMany(relation,primary,foreign){
    
    }
    
    static hasOne(relation,primary,foreign){
    
    }

}