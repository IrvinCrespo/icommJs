var Base = require("./functions");
//var functions = new Base();
var _funs = Symbol();
var functions = Symbol()
module.exports = class Model{
    
    
    constructor(props,table,primary){
        this[_funs] = new Base();
        this[functions] = new Base()
        if(props) Object.assign(this,props);
        if(table && primary){
            console.log("TABLA: ",table)
            this[functions].config(table,primary)
        }
        else this[functions].config(this.table,this.primaryKey)
        
    }

    static set funs(f){
        functions
    }
    static get funs(){
        return new Base()
    }

    static config(table,primary){
        this[functions].config(table,primary)
    }

    static set functionsx(functions){
        this[functions] = functions
    }

    static get _t(){
        return this.table
    }

    static get _pk(){
        return this.primaryKey
    }

    static get table(){
        
    }

    static get primaryKey(){
        
    }

    static build(){
        //this.functions

        var functionsx = new Base();
        functionsx.config(this.table,this.primaryKey);
        //this.config(this.table,this.primaryKey)
        console.log(functionsx)
        return functionsx
    }

    watcher(prop,oldVal,newVal){
        
        if(newVal != oldVal){
            this.changed.push(newVal)
        }else{
            this.changed.pop(newVal);
        }
    }
    
    setTable(table){
        this.table = table;
    }

    async save(){
        var props = Object.assign({}, this);
        //Object.assign(this,props);
        return await this[functions].save(props)
        .then(res=>{
            if(res.insertId && res.insertId > 0){
                
                Object.defineProperty(this,res.primaryKeyName,{
                    value:res.insertId,
                    writable: true,
                    enumerable: true,
                    configurable: true});
                var props = Object.assign({}, this);
            }
            return res;
        })
        .catch(error=>{

        });

    }

    async delete(){
        var props = Object.assign({}, this);
        return await this[functions].delete(props)
        .then(res=>{
            return res;
        })
        .catch(error=>{
            
        });
    }

    static async destroy(){
        return this[functions].destroy()
        .then(res=>{
            return res;
        })
        .catch(error=>{

        });
    }

    static async join(relation,primary,foreign){
        this.functions.andWhere(relation,primary,foreign);
        return this
    }

    static async find(id){
        
        let props = await this[functions].find(id)
        .then(res=>{
            return res;
        }).catch(error=>{
            throw error
        });
        if(props){
            Object.assign(this,props);
            return new Model(props,this.table,this.primaryKey);
        }
        return props;
        
    }

    static select(fields){
        this.query = this[functions].select(fields);
        return this
    }

    static join(relation,primary,foreign){
        this[functions].join(relation,primary,foreign);
        return this
    }
    
    static andWhere(key,op,val){
        this[functions].andWhere(key,op,val);
        return this
    }
    
    static where(key,op,val){
        this.query = this[functions].where(key,op,val);
        return this
    }
    
    static orWhere(key,op,val){
        return this
    }

    static async update(fields){
        let res = await this[functions].update(fields)
        .then(res=>{
            return res;
        })
        .catch(error=>{

        });
        return res;
    }
    
    //Regresa un array de registros
    static async take(number){
        let props = await this[functions].take(number)
        .then(res=>{
            return res;
        }).catch( error =>{
            
        });
       
        return props
    }
    
    
    static orderBy(field,sort){
        this[functions].orderBy(field,sort);
        return this
    }

    static async first(){
        let props = await this[functions].first()
        .then(res=>{
            //console.log("RES: ",res);
            return res;
        }).catch( error =>{
            
        });

        return props;
    }

    static async all(){
        let props = await this[functions].all()
        .then(res=>{
            return res;
        }).catch( error =>{
            
        });
        return props;
    }
    
    static hasMany(relation,primary,foreign){
    
    }
    
    static hasOne(relation,primary,foreign){
    
    }

}