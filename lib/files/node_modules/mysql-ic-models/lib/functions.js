var connection = null;
var connect = require("./connection").connection;

var table = "";
var primaryKey = "";
var wheres = [];
var orWheres = [];
var andWheres = [];
var joins = [];
var query = "";

var extras;

build();
function config(tab,primary){
    table = tab
    primaryKey = primary?primary:"id";
    query = "SELECT * FROM "+table;
}

function build(){
    connect(function(err,connec){
       
        connection = connec
    })
}

function first(){
    query += " LIMIT 1;";
    console.log("LA QUERYYY: ",query);
    return new Promise((result,reject)=>{
        connect(function(err,connection){
            connection.escape(query);
            connection.query(query,function(err,res){
                connection.release();
                if(err) return reject(err)
                var string= JSON.stringify(res);
                var json =  JSON.parse(string);
                return result(json[0])
            });
        })
        
    })
}

function all(){
    return new Promise((result,reject)=>{
        connection.query(query,function(err,res){
            connect(function(err,connection){
                connection.escape(query);
                connection.query(query,function(err,res){
                    connection.release();
                    if(err) return reject(err)
                    var string= JSON.stringify(res);
                    var json =  JSON.parse(string);
                    return result(json)
                });
            })
        });
    })
}

function select(fields){
    var selectf = "*"
    if(fields)selectf = ""+fields.join(",")+"";
    var replaces = "SELECT "+primaryKey+","+selectf+" ";
    query = query.replace("SELECT * ",replaces);
    return query;
}

function where(key,op,val){
    query+=" WHERE "+key+" "+op+" "+(!isNaN(val)?parseInt(val):"'"+val+"'")+"";
    return query;
}

function andWhere(key,op,val){
    var str = connection.escape(key+op+val);
    query+= " AND " + str;
    wheres.push({
        key:key,
        operador:op,
        value:val,
        condition:" AND "
    });
    return query;
}

function orWhere(key,op,val){
    var str = connection.escape(key+op+val);
    query+= " AND " + str;

    wheres.push({
        key:key,
        operador:op,
        value:val,
        condition:" OR "
    });
    return query;
}

function find(id){
    query += " WHERE "+primaryKey+" = "+id
    console.log("QUERY: ",query);
    return new Promise((result,reject)=>{
        connect(function(err,connection){
            connection.escape(query);
            connection.query(query,function(err,res){
                connection.release();
                if(err) return reject(err)
                var string= JSON.stringify(res);
                var json =  JSON.parse(string);
                return result(json[0])
            });
        })
        
    })
}

function top(){

}

function desc(){
    
}

function asc(){

}

function orderBy(field){

}

function hasMany(relation,primary,foreign){

}

function hasOne(relation,primary,foreign){

}

//Manipulating data

function create(props){
    var fields = []
    var values = []
    var strvals = "VALUES(";
    query = "INSERT INTO "+table+"(";
    let length = Object.keys(props).length;
    var count = 1;
    Object.keys(props).forEach(function(key) {
        values.push(props[key])
        query += key
        strvals += "?"
        if(count < length){
            query+=","
            strvals+=","
        }
        count++;
    })
    strvals+=")"
    query+=") "+strvals;
    return new Promise((result,reject)=>{
        connect(function(error,connection){
            values.forEach(element => {
                connection.escape(element);
            });
            connection.query(query,values,function(err,res,rows,fields){
                console.log("Error: ",err);
                if(err)return reject(err)
                return result(res)
            });
        })
    });

}

function update(props){
    var fields = []
    var values = []
    query = "UPDATE "+table+" SET ";
    let length = Object.keys(props).length;
    var count = 1;
    Object.keys(props).forEach(function(key) {
        //fields.push(key)
        values.push(props[key])
        query += key+" = ?"
        if(count < length)
            query+=","
        count++;
    })
    query+= " WHERE "+primaryKey+" = ?"
    values.push(props[primaryKey]);
    
    return new Promise((result,reject)=>{
        connect(function(error,connection){
            
            values.forEach(element => {
                connection.escape(element);
            });
           
            connection.query(query,values,function(err,res,rows,fields){
                console.log("Error: ",err);
                if(err)return reject(err)
                return result(res)
            });
        })
    });
    
}

module.exports = {
    find:find,
    first:first,
    all:all,
    update:update,
    create:create,
    where:where,
    andWhere:andWhere,
    orWhere:orWhere,
    select:select,
    orderBy:orderBy,
    top:top,
    asc:asc,
    desc:desc,
    hasMany:hasMany,
    hasOne:hasOne,
    table:table,
    config:config
}