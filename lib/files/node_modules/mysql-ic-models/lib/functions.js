var connection = null;
var connect = require("./connection").connection;

var table = "";
var primaryKey = "";
var wheres = [];
var orWheres = [];
var andWheres = [];
var joins = [];
var orderby = "";

var query = "";

module.exports = class BaseBuilder{
    //build();
 
constructor(){
    //this.table = table;
    //this.primaryKey = primary;
    this.wheres = [];
    this.orWheres = [];
    this.andWheres = [];
    this.joins = [];
    this.orderby = "";
    this.query = "";
    this.fields = []
}
config(tab,primary){
    this.table = tab
    this.primaryKey = primary?primary:"id";
    //query = "SELECT * FROM "+table;
    this.query = "";
}

build(){
    connect(function(err,connec){
       
        connection = connec
    })
}


first(){
    this.query += " LIMIT 1;";
    var self = this;
    if(this.query.search("SELECT") == -1){
        this.query = ("SELECT * FROM "+this.table).concat(this.query);
    }
    console.log("QB: ",this.query)
    if(this.joins.length > 0)
        this.buildJoins();
    this.buildExtras()
    //console.log("QUERY: ",this.query)
    var m =  new Promise((result,reject)=>{
        connect(function(err,connection){
            connection.escape(self.query);
            connection.query(self.query,function(err,res){
                self.query = "";
                connection.release();
            
                if(err){
                    console.log("QUERY: ",self.query)
                    return reject(err)
                } 
                var string= JSON.stringify(res);
                var json =  JSON.parse(string);
                //console.log("RESULTADO: ",json[0])
                return result(json[0])
            });
        })
        
    }).then(res=>{
        return res
    })
    return m
}

all(){
    if(this.join.length > 0)
        this.buildJoins();
    this.buildExtras()
    var self = this
    return new Promise((result,reject)=>{
        connect(function(err,connection){
            connection.escape(self.query);
            connection.query(self.query,function(err,res){
                connection.release();
                self.query = "";
                if(err) return reject(err)
                var string= JSON.stringify(res);
                var json =  JSON.parse(string);
                return result(json)
            });
        })
        
    })
}

select(fields){
    var selectf = "*"
    if(this.join.length > 0)
        if(fields){
            if(this.joins.length <= 0)fields.push(this.primaryKey)
            this.fields = fields
            selectf = fields.join(",")+""
        }
    else
        if(fields){
            if(this.joins.length <= 0)fields.push(this.primaryKey)
            this.fields = fields
            selectf = this.table+"."+this.primaryKey+","+fields.join(",")+""
        }
    
    this.query = ("SELECT "+selectf+" FROM "+this.table).concat(this.query);
    return this;
}

where(key,op,val){
    this.query+=" WHERE "+key+" "+op+" "+(!isNaN(val)?parseInt(val):"'"+val+"'")+"";
    return this;
}

/*where(key,builder){
    //this.query+=" WHERE "+key+" "+op+" "+(!isNaN(val)?parseInt(val):"'"+val+"'")+"";
    return this;
}*/

andWhere(key,op,val){
    var str = key+op+(!isNaN(val)?parseInt(val):"'"+val+"'")+"";
    this.query+= " AND " + str;
    this.wheres.push({
        key:key,
        operador:op,
        value:val,
        condition:" AND "
    });
    return this;
}

orWhere(key,op,val){
    var str = connection.escape(key+op+val);
    this.query+= " OR " + str;
    
    this.wheres.push({
        key:key,
        operador:op,
        value:val,
        condition:" OR "
    });
    return this;
}

//Regresar modelo :V
find(id){
    this.query += " WHERE "+this.primaryKey+" = "+id
    this.query = ("SELECT * FROM "+this.table).concat(this.query);
    
    var self = this;
    return new Promise((result,reject)=>{
        connect(function(err,connection){
            connection.escape(self.query);
            connection.query(self.query,function(err,res){
                connection.release();
                if(err) return reject(err)
                if(res.length > 0){
                    var string= JSON.stringify(res);
                    var json =  JSON.parse(string);
                    return result(json[0])
                }
                else
                    return result(null)
                
            });
        })
        
    })
}


save(props){

    if(props[this.primaryKey]){
        return this.update(props)
    }else{
        return this.create(props)
    }
}

delete(props){
    if(props[this.primaryKey]){
        this.query = "DELETE FROM "+this.table +" WHERE "+this.primaryKey +" = "+props[this.primaryKey];
        var tmp = this.query
        
        return new Promise((resolve,reject)=>{
            connect(function(error,connection){
                connection.escape(tmp);
                connection.query(tmp,function(err,res,rows,fields){
                    connection.release();
                    if(err)return reject(err);
                    
                    return resolve(res.affectedRows)
                });
            })
        }); 

    }else{
        return new Promise((resolve,reject)=>{
            return reject(new Error("No existe una llave primaria para eliminar este modelo.\nAsegurate de que el modelo o tabla, este referenciado con una llave primaria o\
             de otra manera, si esto no es posible, utilize la funcion destroy con una consulta filtrada por otros campos"))
        }).catch(error=>{
            throw new Error("No existe una llave primaria para eliminar este modelo.\nAsegurate de que el modelo o tabla, este referenciado con una llave primaria o\
            de otra manera, si esto no es posible, utilize la funcion destroy con una consulta filtrada por otros campos")
        }); 
        //return create(props)
    }
}

destroy(){
    var tmp = ("DELETE FROM "+this.table).concat(this.query);
    return new Promise((resolve,reject)=>{
        connect(function(error,connection){
            connection.escape(tmp);
            connection.query(tmp,function(err,res,rows,fields){
                connection.release();
                if(err)return reject(err);
                return resolve(res.affectedRows)
            });
        })
    }); 
}

count(field = "*"){
    if(this.query.search("SELECT") == -1){
        this.query = ("SELECT count("+field+") FROM "+this.table).concat(this.query);
    }else{
        if(this.fields){
            var selectf = fields.join(",")+""
            this.query.replace("SELECT "+selectf+" FROM "+this.table,"SELECT count("+field+") FROM "+this.table)
        }
    }
    //if()
}

//Manipulating data

create(props){
    var fields = []
    var values = []
    var strvals = "VALUES(";
    this.query = "INSERT INTO "+this.table+"(";
    let length = Object.keys(props).length;
    var count = 1;
    var self = this;
    Object.keys(props).forEach(function(key) {
        values.push(props[key])
        self.query += key
        strvals += "?"
        if(count < length){
            self.query+=","
            strvals+=","
        }
        count++;
    })
    strvals+=")"
    this.query+=") "+strvals;
    //console.log("SAVE: ",this.query)
    return new Promise((result,reject)=>{
        connect(function(error,connection){
            if(error) throw error;
            values.forEach(element => {
                connection.escape(element);
            });
            connection.query(self.query,values,function(err,res,rows,fields){
               // console.log(">ERROR: ",err)
                connection.release();
                if(err){
                    console.log("QUERY: ",self.query)
                    return reject(err)
                }
               
                res.primaryKeyName = self.primaryKey;
                return result(res)
            });
        })
    });

}

rawQuery(query){
    return new Promise((result,reject)=>{
        connect(function(error,connection){
            connection.query(query,function(err,res){
               // console.log(">ERROR: ",err)
                connection.release();
                if(err){
                    console.log("QUERY: ",query)
                    return reject(err)
                }
                var string= JSON.stringify(res);
                var json =  JSON.parse(string);
                return result(json)
            });
        })
    });
}

updateMass(fields){
    //{field:value}
    var values = []
    let length = Object.keys(fields).length;
    var count = 1;
    var tmp = "";
    //query = query.replace("UPDATE "+table+" SET ",);
    //console.log("FIELDS: ",fields);
    Object.keys(fields).forEach(function(key) {
        //fields.push(key)
        values.push(fields[key])
        tmp += key+" = ?"
        if(count < length)
            tmp+=","
        count++;
    })
    this.query = ("UPDATE "+table+" SET "+tmp).concat(query);
    
    return new Promise((result,reject)=>{
        connect(function(error,connection){
            
            values.forEach(element => {
                connection.escape(element);
            });
           
            connection.query(this.query,values,function(err,res,rows,fields){
                connection.release()
                if(err)return reject(err)
                return result(res.changedRows)
            });
        })
    }); 

}

update(props){
    var fields = []
    var values = []
    this.query = "UPDATE "+this.table+" SET ";
    let length = Object.keys(props).length;
    var count = 1;
    var self = this
    Object.keys(props).forEach(function(key) {
        //fields.push(key)
        values.push(props[key])
        self.query += key+" = ?"
        if(count < length)
            self.query+=","
        count++;
    })
    this.query+= " WHERE "+this.primaryKey+" = ?"
    values.push(props[this.primaryKey]);
    
    return new Promise((result,reject)=>{
        connect(function(error,connection){
            
            values.forEach(element => {
                connection.escape(element);
            });
            //console.log("-----------------------------------")
            //console.log(self.query,values)
            connection.query(self.query,values,function(err,res,rows,fields){
                connection.release();
                if(err)return reject(err)
                return result(res)
            });
        })
    });
    
}

buildJoins(){
    var strjoin = "";
    this.joins.forEach(element => {
        strjoin+=" "+element.type+" JOIN "+element.table+" ON "+element.primary+" = "+element.foreign+" "
    });

    this.query = this.query.replace("FROM "+this.table,"FROM "+this.table+strjoin);
    console.log("BUILDED: ",this.query)
    return this.query;  
}

buildExtras(){
    if(orderby){
        this.query += this.orderby
    }
    return this.query
}

join(relation,primary,foreign){
    this.joins.push({
        type:"INNER",
        table:relation,
        primary:primary,
        foreign:foreign
    });
    
    return this
}

take(number){
    this.query += " LIMIT "+number;
    buildExtras();
    if(join.length > 0)
        buildJoins();
    return new Promise((result,reject)=>{
        connect(function(err,connection){
            connection.escape(this.query);
            connection.query(this.query,function(err,res){
                connection.release();
                if(err) return reject(err)
                var string= JSON.stringify(res);
                var json =  JSON.parse(string);
                return result(json[0])
            });
        })
        
    })
}

 orderBy(field,sort){
    this.orderby = " ORDER BY "+field+" "+sort
    return this.query
 }

 hasMany(relation,primary,foreign){

 }

 hasOne(relation,primary,foreign){

 }
}
