var redis = require("redis");
var client = redis.createClient();
var multi = client.multi();
module.exports = class Base{

    constructor(){    
        this.IsJsonString.bind(this)
    }
    
    pushToList(list,data){
        if(data instanceof Object){
            data = JSON.stringify(data)
            //console.log("STRINGIFY")
        }
        return client.lpush(list,data,redis.print)
    }

    sadd(set,member){
        return new Promise((resolve,reject)=>{
            client.sadd(set,member,(err,reply)=>{
                if(err) return reject(err)
                return resolve(reply)
            })
        }).then(res=>{return res},rej=>{return rej})
        
    }
    srem(set,member){
        return new Promise((resolve,reject)=>{
            client.srem(set,member,(err,reply)=>{
                if(err) return reject(err)
                return resolve(reply)
            })
        }).then(res=>{return res},rej=>{return rej})
    }
    smembers(set){
        return new Promise((resolve,reject)=>{
            client.smembers(set,(err,reply)=>{
                if(err) return reject(err)
                return resolve(reply)
            })
        }).then(res=>{return res},rej=>{return rej})
    }

    //Obtiene una lista a partir de la key
    getlist(list,start = 0,stop = -1,truncate=false,behaviorForEachItem = null){
        return new Promise((resolve,reject)=>{
            client.lrange(list,start,stop,(error,reply)=>{
                if(error)return reject(error);
                var array = []
                for (let i = 0; i < reply.length; i++) {
                    var elem = reply[i];
                    try {
                        elem = JSON.parse(reply[i]);
                    } catch (e) {
                        elem = reply[i];
                    }                    
                    array.push(elem);
                    if(behaviorForEachItem)
                        behaviorForEachItem(elem)
                    if(truncate)client.lrem(list, 1, reply[i]);
                }
                return resolve(array);
            })
        });
    }

    getlistAsSingleItem(list,start = 0,stop = -1,truncate=false,behaviorForEachItem = null){
        return new Promise((resolve,reject)=>{
            client.lrange(list,start,stop,(error,reply)=>{
                if(error)return reject(error);
                var array = []
                return resolve(reply)

                for (let i = 0; i < reply.length; i++) {
                    var elem = reply[i];
                    elem = reply[i];
                    array.push(elem);
                    if(behaviorForEachItem)
                        behaviorForEachItem(elem)
                    if(truncate)client.lrem(list, 1, reply[i]);
                }
                return resolve(array);
            })
        });
    }

    //Toma el valor del campo de un hash especifico 
    getHashField(hash,field){
        return new Promise((resolve,reject)=>{
            client.hget(hash,field,function(error,reply){
                if(error)return reject(error)
                return resolve(reply)
            })
        }).catch(e=>{

        });
    }

    delHashFields(hash,fields){
        return new Promise((resolve,reject)=>{
            client.del(hash,field,function(error,reply){
                if(error)return reject(error)
                return resolve(reply)
            })
        }).catch(e=>{
            
        });
    }

    delHasField(hash,field){
        return new Promise((resolve,reject)=>{
            client.hdel(hash,field,function(error,reply){
                if(error)return reject(error)
                return resolve(reply)
            })
        }).catch(e=>{

        });
    }

    delField(key,field){

    }

    //Obtiene multiples registros de un arreglo de hashes
    getMultiHashField(hashes,field,prefixKey=null,sufix=null){
        for (let i = 0; i < hashes.length; i++) {
            var el = hashes[i]
            if(prefixKey) el=prefixKey+el;
            if(sufix) el=el+sufix;
            multi.hget(el,field)
        }
        return new Promise((resolve,reject)=>{
            multi.exec(function(err,res){
                if(err)return reject(err)
                return resolve(res)
                
            })
        });
       
    }

    //Agrega elemento a un a lista especifica
    addToList(list,data){
        var resu = client.lpush(list,JSON.stringify(data),redis.print);
    }
    //crea o edita un hash con la data que recibe, en este caso un JSON
    setHash(hash,data){
        return new Promise((resolve,reject)=>{

            client.hmset(hash,data,(err,reply)=>{
                if(err) return reject(err)
                return resolve(reply)
            });
        })
        
    }


    IsJsonString(str) {
        try {
            JSON.parse(str);
        } catch (e) {
            return false;
        }
        return true;
    }

    //Crea o actualiaza una key y agrega tiempo de expiracion en segundos.
    setKey(key,val,expiration=0){
        client.set(key,val)
        if(expiration > 0)
            client.expire(key,expiration)
    }

    setHashField(key,field,value){
        return new Promise((resolve,reject)=>{
            client.hset(key,field,value,(error,reply)=>{
                if(error)return reject(error)
                return resolve(reply)
            })
        });
        
    }

    increaseField(key,field,value){
        return new Promise((resolve,reject)=>{
            client.hincrby(key,field,value,(err,rep)=>{
                if(err){
                    return reject(err)
                }
                return resolve(rep)
            })
        });
    }

    //Crea o actualiza varios campos en un hash
    setManyHashFields(key,array){
        var arr = [key]
        arr.push(array)
        return new Promise((resolve,reject)=>{
            client.hmset(arr, function (error, reply) {
                if(error)return reject(error)
                return resolve(reply)
            });
        });
        
    }

}